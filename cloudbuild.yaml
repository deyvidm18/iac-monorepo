steps:
# Step 1: Install Tools, Detect Changes, and Generate Plans
- id: 'Install Tools, Detect Changes, and Generate Plans'
  name: 'gcr.io/cloud-builders/gcloud'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    set -e # Exit immediately on error

    # Install Terraform and Terragrunt
    apt-get update && apt-get install -y unzip wget
    wget https://releases.hashicorp.com/terraform/1.6.0/terraform_1.6.0_linux_amd64.zip
    unzip terraform_1.6.0_linux_amd64.zip
    mv terraform /usr/local/bin/
    chmod +x /usr/local/bin/terraform
    wget https://github.com/gruntwork-io/terragrunt/releases/download/v0.58.10/terragrunt_linux_amd64
    mv terragrunt_linux_amd64 /usr/local/bin/terragrunt
    chmod +x /usr/local/bin/terragrunt

    # Install Infracost
    wget https://github.com/infracost/infracost/releases/download/v0.10.42/infracost-linux-amd64.tar.gz
    tar -xvf infracost-linux-amd64.tar.gz
    mv infracost-linux-amd64 /usr/local/bin/infracost
    chmod +x /usr/local/bin/infracost
    
    # Persist binaries to /workspace/bin for subsequent steps
    mkdir -p /workspace/bin
    cp /usr/local/bin/infracost /workspace/bin/

    # Create a directory for plan files
    mkdir -p /workspace/plans

    if [ -n "$_PR_NUMBER" ]; then
      ACTION="plan"
      git fetch --unshallow
      CHANGED_FILES=$(git diff --name-only origin/$_BASE_BRANCH...origin/$_HEAD_BRANCH)
      
      # Fetch Infracost API key for breakdown
      echo "Fetching Infracost API key..."
      gcloud secrets versions access latest --secret=infracost-api-key --project=$PROJECT_ID --format='get(payload.data)' | tr '_-' '/+' | base64 -d > /workspace/infracost_api_key.txt
      export INFRACOST_API_KEY=$(cat /workspace/infracost_api_key.txt)
    else
      ACTION="apply"
      git fetch --depth=2
      CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
    fi

    echo "Action: $$ACTION"
    echo "Changed files: $$CHANGED_FILES"

    # Detect Target Directories
    if echo "$$CHANGED_FILES" | grep -q "modules/" || echo "$$CHANGED_FILES" | grep -q "env.hcl"; then
      echo "Shared module or environment default changed, targeting ALL applications."
      TARGET_DIRS=$(find live -type f -name 'terragrunt.hcl' | xargs dirname)
    else
      TARGET_DIRS=$(echo "$$CHANGED_FILES" | grep -o 'live/[^/]*/[^/]*' | sort | uniq)
    fi

    if [ -z "$$TARGET_DIRS" ]; then
      echo "No infrastructure changes detected. Exiting."
      touch /workspace/target_dirs.txt # Create empty file to signal no changes
      exit 0
    fi
    
    echo "$$TARGET_DIRS" > /workspace/target_dirs.txt
    echo "Target directories to process:"
    cat /workspace/target_dirs.txt

    PLAN_FAILED=false
    # Generate plans or apply changes
    for DIR in $$TARGET_DIRS;
    do
      (
        echo "--- Processing $$DIR ---"
        cd "$$DIR"
        if [ "$$ACTION" == "plan" ]; then
          # Sanitize directory name for the filename
          PLAN_FILENAME=$(echo "$$DIR" | sed 's/[^a-zA-Z0-9]/-/g')
          
          # Generate binary plan
          terragrunt plan -out=plan.binary -no-color > /dev/null 2>&1
          if [ $$? -ne 0 ]; then
            PLAN_FAILED=true
            # Capture error output if plan failed
            terragrunt plan -no-color > "/workspace/plans/$${PLAN_FILENAME}.txt" 2>&1
          else
            # Convert to text for existing logic
            terragrunt show -no-color plan.binary > "/workspace/plans/$${PLAN_FILENAME}.txt"
            
            # Convert to JSON for Infracost
            terragrunt show -json plan.binary > "/workspace/plans/$${PLAN_FILENAME}.json"
            
            # Run Infracost breakdown
            infracost breakdown --path "/workspace/plans/$${PLAN_FILENAME}.json" --format json --out-file "/workspace/plans/$${PLAN_FILENAME}_infracost.json" || true
          fi
        else
          terragrunt apply --terragrunt-non-interactive --auto-approve
        fi
      )
    done

    if [ "$$PLAN_FAILED" = true ]; then
      echo "One or more Terragrunt plans failed. Exiting with error."
      exit 1
    fi

# Step 2: Fetch GitHub Token
- id: 'Fetch GitHub Token'
  name: 'gcr.io/cloud-builders/gcloud'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    if [ -n "$_PR_NUMBER" ]; then
      echo "Fetching GitHub token..."
      gcloud secrets versions access latest --secret=github-token --project=$PROJECT_ID --format='get(payload.data)' | tr '_-' '/+' | base64 -d > /workspace/github_token.txt
      
      echo "Fetching Infracost API key..."
      gcloud secrets versions access latest --secret=infracost-api-key --project=$PROJECT_ID --format='get(payload.data)' | tr '_-' '/+' | base64 -d > /workspace/infracost_api_key.txt
    fi

# Step 3: Post Plan to GitHub PR
- id: 'Post Plan to GitHub PR'
  name: 'gcr.io/cloud-builders/gcloud'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    set -e
    if [ -n "$_PR_NUMBER" ]; then
      if [ ! -s /workspace/target_dirs.txt ]; then
        echo "No target directories to process. Skipping comment."
        exit 0
      fi

      apt-get update && apt-get install -y jq

      GITHUB_TOKEN=$(cat /workspace/github_token.txt)
      TARGET_DIRS=$(cat /workspace/target_dirs.txt)
      COMMENTS_URL="https://api.github.com/repos/$REPO_FULL_NAME/issues/$_PR_NUMBER/comments"
      
      ALL_COMMENTS=$(curl -s -H "Authorization: token $$GITHUB_TOKEN" -H "Accept: application/vnd.github.v3+json" "$$COMMENTS_URL")

      for DIR in $$TARGET_DIRS;
      do
        PLAN_FILENAME=$(echo "$$DIR" | sed 's/[^a-zA-Z0-9]/-/g')
        PLAN_OUTPUT=$(cat "/workspace/plans/$${PLAN_FILENAME}.txt")

        if echo "$$PLAN_OUTPUT" | grep -q "level=error"; then
          PLAN_SUMMARY="‚ùå Error: Terragrunt plan failed."
        elif echo "$$PLAN_OUTPUT" | grep -q "No changes. Your infrastructure matches the configuration."; then
          PLAN_SUMMARY="No changes. Your infrastructure matches the configuration."
        else
          PLAN_SUMMARY=$(echo "$$PLAN_OUTPUT" | grep -o 'Plan:.*' || echo "Plan: No changes.")
        fi

        COMMENT_MARKER="<!-- terragrunt-plan-for: $$DIR -->"
        COMMENT_TITLE="### Terragrunt Plan for \`$$DIR\`"
        COMMENT_BODY=$(printf '%s\n**%s**\n<details><summary>Full Plan Output</summary>\n\n```\n%s\n```\n</details>\n%s' \
          "$$COMMENT_TITLE" "$$PLAN_SUMMARY" "$$PLAN_OUTPUT" "$$COMMENT_MARKER")

        EXISTING_COMMENT_ID=$(echo "$$ALL_COMMENTS" | jq --arg marker "$$COMMENT_MARKER" '.[] | select(.body | contains($marker)).id')
        JSON_PAYLOAD=$(jq -n --arg body "$$COMMENT_BODY" '{body: $body}')

        if [ -n "$$EXISTING_COMMENT_ID" ]; then
          echo "Updating existing comment $$EXISTING_COMMENT_ID for $$DIR"
          curl -s -X PATCH -H "Authorization: token $$GITHUB_TOKEN" \
            "https://api.github.com/repos/$REPO_FULL_NAME/issues/comments/$$EXISTING_COMMENT_ID" -d "$$JSON_PAYLOAD"
        else
          echo "Creating new comment for $$DIR"
          curl -s -X POST -H "Authorization: token $$GITHUB_TOKEN" \
            "$$COMMENTS_URL" -d "$$JSON_PAYLOAD"
        fi
      done
    else
      echo "Not a PR. Skipping comment."
    fi

# Step 4: Post Infracost Comment
- id: 'Post Infracost Comment'
  name: 'gcr.io/cloud-builders/gcloud'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    set -e
    if [ -n "$_PR_NUMBER" ]; then
      if [ ! -s /workspace/target_dirs.txt ]; then
        echo "No target directories to process. Skipping Infracost comment."
        exit 0
      fi

      # Install Infracost (re-installing here to be safe, or could rely on previous step if image persisted, but standard cloud builders don't persist /usr/local/bin across steps unless using a custom image or workspace)
      # Actually, /workspace is persisted. /usr/local/bin is NOT.
      # So we need to reinstall or use the one we installed in Step 1 if we moved it to /workspace.
      # Let's just install it again or put it in /workspace/bin in Step 1.
      
      # Better yet, let's assume we installed it in Step 1 and moved it to /workspace/bin
      export PATH=$$PATH:/workspace/bin

      export INFRACOST_API_KEY=$(cat /workspace/infracost_api_key.txt)
      export GITHUB_TOKEN=$(cat /workspace/github_token.txt)

      # Find all infracost JSON files
      INFRACOST_FILES=$(find /workspace/plans -name "*_infracost.json")
      
      if [ -z "$$INFRACOST_FILES" ]; then
        echo "No Infracost files found."
      else
        echo "Posting Infracost comment..."
        infracost comment github --repo $REPO_FULL_NAME --pull-request $_PR_NUMBER --path "/workspace/plans/*_infracost.json" --behavior update --github-token $$GITHUB_TOKEN
      fi
    fi

# Step 5: Post /gemini summary comment
# Step 5: Post Gemini Summary
- id: 'Post Gemini Summary'
  name: 'python:3.9-slim'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    set -e
    if [ -n "$_PR_NUMBER" ]; then
      if [ ! -s /workspace/target_dirs.txt ]; then
        echo "No target directories to process. Skipping summary."
        exit 0
      fi

      # Install dependencies
      pip install google-generativeai requests

      # Create a python script to generate summary and post comment
      # Create a python script to generate summary and post comment
      cat <<EOF | sed 's/^      //' > /workspace/gemini_summary.py
      import os
      import glob
      import google.generativeai as genai
      import requests
      import json

      # Configure Gemini
      # Note: This assumes ADC is available or API key is provided. 
      # Cloud Build uses the service account, which should have Vertex AI User role.
      
      PROJECT_ID = os.environ.get("PROJECT_ID")
      LOCATION = "us-central1" # Default
      genai.configure(platform="GOOGLE_CLOUD_VERTEX_AI", project=PROJECT_ID, location=LOCATION)

      model = genai.GenerativeModel('gemini-pro')

      # Gather plans
      plans = []
      for plan_file in glob.glob("/workspace/plans/*.txt"):
          with open(plan_file, 'r') as f:
              content = f.read()
              plans.append(f"Plan for {os.path.basename(plan_file)}:\n{content}\n")

      if not plans:
          print("No plans found.")
          exit(0)

      prompt = "Please summarize the following Terraform plans. Highlight the key changes, additions, and deletions for each module. Be concise.\n\n" + "\n".join(plans)

      try:
          response = model.generate_content(prompt)
          summary = response.text
      except Exception as e:
          print(f"Error generating summary: {e}")
          summary = "Failed to generate summary."

      # Post to GitHub
      GITHUB_TOKEN = os.environ.get("GITHUB_TOKEN")
      REPO_FULL_NAME = os.environ.get("REPO_FULL_NAME")
      PR_NUMBER = os.environ.get("_PR_NUMBER")
      COMMENTS_URL = f"https://api.github.com/repos/{REPO_FULL_NAME}/issues/{PR_NUMBER}/comments"

      comment_marker = "<!-- gemini-summary-comment -->"
      comment_body = f"### ü§ñ Gemini Infrastructure Summary\n\n{summary}\n\n{comment_marker}"

      headers = {
          "Authorization": f"token {GITHUB_TOKEN}",
          "Accept": "application/vnd.github.v3+json"
      }

      # Check for existing comment
      existing_comment_id = None
      try:
          resp = requests.get(COMMENTS_URL, headers=headers)
          resp.raise_for_status()
          comments = resp.json()
          for comment in comments:
              if comment_marker in comment.get("body", ""):
                  existing_comment_id = comment["id"]
                  break
      except Exception as e:
          print(f"Error fetching comments: {e}")

      payload = {"body": comment_body}

      if existing_comment_id:
          print(f"Updating existing comment {existing_comment_id}")
          patch_url = f"https://api.github.com/repos/{REPO_FULL_NAME}/issues/comments/{existing_comment_id}"
          requests.patch(patch_url, headers=headers, json=payload)
      else:
          print("Creating new comment")
          requests.post(COMMENTS_URL, headers=headers, json=payload)
      EOF

      export PROJECT_ID=$PROJECT_ID
      export GITHUB_TOKEN=$(cat /workspace/github_token.txt)
      export REPO_FULL_NAME=$REPO_FULL_NAME
      export _PR_NUMBER=$_PR_NUMBER
      
      python3 /workspace/gemini_summary.py
    fi

options:
  logging: CLOUD_LOGGING_ONLY
